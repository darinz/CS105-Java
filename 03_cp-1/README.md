# Mini Checkpoint Project: Java Review + Functional Decomposition

## Overview

This checkpoint project is designed to reinforce your understanding of Java fundamentals and functional decomposition principles. You'll work on open-ended assignments that encourage exploration and creative problem-solving while applying the concepts learned in the Introduction module.

**Estimated Time**: 2 hours for intermediate level students  
**Focus Areas**: Java Review + Functional Decomposition  
**Project Type**: Open-ended assignments with multiple solution approaches

---

## Learning Objectives

By completing this checkpoint, you will:

- **Apply Java fundamentals** in practical, real-world scenarios
- **Practice functional decomposition** by breaking complex problems into manageable methods
- **Demonstrate code quality** through proper naming conventions and structure
- **Explore creative solutions** to open-ended programming challenges
- **Build confidence** in independent problem-solving and coding

---

## Project Options

Choose **ONE** of the following projects to complete. Each project is designed to be open-ended, allowing you to explore different approaches and add creative features.

### Option 1: Personal Library Management System

Create a Java program to manage a personal book collection with the following features:

**Core Requirements:**
- Add new books (title, author, genre, publication year)
- Display all books in the collection
- Search books by title or author
- Calculate and display collection statistics (total books, average publication year, most common genre)

**Functional Decomposition Requirements:**
- `addBook()` - Add a new book to the collection
- `displayAllBooks()` - Show all books in a formatted way
- `searchBooks()` - Find books by title or author
- `calculateStatistics()` - Generate collection statistics
- `displayMenu()` - Show user options
- `getUserChoice()` - Handle user input

**Open-Ended Extensions** (choose 2-3):
- Sort books by different criteria (title, author, year)
- Filter books by genre or year range
- Export book list to a simple text file
- Add book ratings and reviews
- Track reading progress (read/unread status)
- Generate reading recommendations based on genre preferences

### Option 2: Smart Calculator with History

Build an enhanced calculator that goes beyond basic arithmetic operations:

**Core Requirements:**
- Perform basic operations (+, -, *, /, %)
- Maintain calculation history
- Display previous calculations
- Clear history or specific entries
- Handle division by zero and invalid inputs

**Functional Decomposition Requirements:**
- `performCalculation()` - Execute mathematical operations
- `addToHistory()` - Store calculation in history
- `displayHistory()` - Show calculation history
- `clearHistory()` - Remove all history entries
- `validateInput()` - Check for valid numbers and operations
- `displayMenu()` - Show calculator options

**Open-Ended Extensions** (choose 2-3):
- Add scientific functions (square root, power, factorial)
- Implement memory functions (M+, M-, MR, MC)
- Add unit conversions (length, weight, temperature)
- Create calculation templates (tip calculator, loan calculator)
- Export calculation history to file
- Add keyboard shortcuts for common operations

### Option 3: Interactive Quiz Game

Develop a quiz game with customizable questions and scoring:

**Core Requirements:**
- Display questions one at a time
- Accept user answers (multiple choice or text)
- Track score and provide feedback
- Show final results with percentage
- Allow multiple quiz attempts

**Functional Decomposition Requirements:**
- `displayQuestion()` - Show current question and options
- `getUserAnswer()` - Collect and validate user input
- `checkAnswer()` - Compare user answer with correct answer
- `updateScore()` - Track current score
- `displayResults()` - Show final score and feedback
- `loadQuestions()` - Initialize quiz questions

**Open-Ended Extensions** (choose 2-3):
- Add different question types (true/false, fill-in-the-blank)
- Implement difficulty levels with different scoring
- Add timer for each question
- Create question categories (science, history, sports)
- Save high scores and display leaderboard
- Allow users to add their own questions

---

## Implementation Guidelines

### Code Quality Standards

1. **Naming Conventions**
   - Use camelCase for variables and methods
   - Use PascalCase for class names
   - Use descriptive, self-documenting names
   - Avoid abbreviations and unclear names

2. **Method Design**
   - Each method should have a single, clear purpose
   - Methods should be focused and manageable in size
   - Use meaningful parameter and return value names
   - Include appropriate comments for complex logic

3. **Program Structure**
   - Organize code logically with clear separation of concerns
   - Use proper indentation and formatting
   - Include a main method that orchestrates the program flow
   - Handle user input validation appropriately

### Functional Decomposition Checklist

- [ ] Break the main problem into 5-8 focused methods
- [ ] Each method has a single, clear responsibility
- [ ] Methods are appropriately sized (not too long or complex)
- [ ] Clear method names that describe their purpose
- [ ] Logical flow between methods
- [ ] Main method acts as an orchestrator

### Java Concepts to Demonstrate

- [ ] Variables and data types (int, double, String, boolean)
- [ ] Control structures (if/else, loops, switch)
- [ ] Arrays or ArrayLists for data storage
- [ ] User input handling with Scanner
- [ ] Method creation and calling
- [ ] Error handling and input validation
- [ ] String manipulation and formatting

---

## Submission Requirements

### 1. Source Code
- Submit your complete Java file(s)
- Ensure code compiles and runs without errors
- Include all necessary import statements

### 2. Documentation
- Add a header comment describing your program
- Include method comments for complex logic
- Document any creative extensions you implemented

### 3. Testing
- Test your program with various inputs
- Ensure error handling works correctly
- Verify all core requirements are met

### 4. Reflection (Optional)
- Briefly describe your approach to functional decomposition
- Explain any challenges you encountered and how you solved them
- Share what you learned or would do differently

---

## Evaluation Criteria

### Functional Requirements (40%)
- All core requirements implemented correctly
- Program runs without errors
- User interface is clear and functional

### Functional Decomposition (30%)
- Problem broken down into appropriate methods
- Methods have single, clear purposes
- Logical organization and flow

### Code Quality (20%)
- Proper naming conventions followed
- Code is readable and well-formatted
- Appropriate comments included

### Creativity and Extensions (10%)
- Implementation of open-ended features
- Creative problem-solving approaches
- Going beyond basic requirements

---

## Getting Started

1. **Choose Your Project**: Select the option that interests you most
2. **Plan Your Approach**: Sketch out the main methods you'll need
3. **Start Simple**: Begin with core requirements before adding extensions
4. **Test Incrementally**: Test each method as you build it
5. **Refactor as Needed**: Improve your code structure as you go

---

## Tips for Success

- **Start with a plan**: Sketch out your main methods before coding
- **Build incrementally**: Add one feature at a time and test it
- **Keep it simple**: Focus on clean, working code over complex features
- **Ask for help**: If you get stuck, review the functional decomposition materials
- **Be creative**: Don't be afraid to add your own unique features

---

**Remember**: This is an opportunity to demonstrate your understanding of Java fundamentals and functional decomposition. Focus on writing clean, well-organized code that solves the problem effectively!

**Good luck with your Mini Checkpoint Project!**